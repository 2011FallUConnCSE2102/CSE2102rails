/* $Header: /Users/blentz/rails_rcs/cvs/18xx/rails/game/TrainManager.java,v 1.28 2010/04/21 21:25:50 evos Exp $ */package rails.game;import java.util.*;import rails.game.state.BooleanState;import rails.game.state.IntegerState;import rails.util.LocalText;import rails.util.Tag;public class TrainManager implements ConfigurableComponentI {    // Static attributes    protected List<TrainTypeI> lTrainTypes = new ArrayList<TrainTypeI>();    protected Map<String, TrainTypeI> mTrainTypes =            new HashMap<String, TrainTypeI>();    protected Map<String, TrainI> trainMap =        new HashMap<String, TrainI>();        private boolean removeTrain = false;        // Dynamic attributes    protected Portfolio unavailable = null;    protected IntegerState newTypeIndex;    protected boolean trainsHaveRusted = false;    protected boolean phaseHasChanged = false;    protected boolean trainAvailabilityChanged = false;    protected List<PublicCompanyI> companiesWithExcessTrains;    protected GameManagerI gameManager = null;    protected Bank bank = null;        /** Required for the sell-train-to-foreigners feature of some games */    protected BooleanState anyTrainBought = new BooleanState ("AnyTrainBought", false);    // Non-game attributes    protected Portfolio ipo = null;        // For initialisation only    boolean trainPriceAtFaceValueIfDifferentPresidents = false;    /**     * No-args constructor.     */    public TrainManager() {        newTypeIndex = new IntegerState("NewTrainTypeIndex", 0);    }    /**     * @see rails.game.ConfigurableComponentI#configureFromXML(org.w3c.dom.Element)     */    public void configureFromXML(Tag tag) throws ConfigurationException {        TrainType defaultType = null;        TrainType newType;        Tag defaultsTag = tag.getChild("Defaults");        if (defaultsTag != null) {            defaultType = new TrainType(false);            defaultType.configureFromXML(defaultsTag);        }        List<Tag> typeTags = tag.getChildren("Train");        for (Tag typeTag : typeTags) {            if (defaultType != null) {                newType = (TrainType) defaultType.clone();                if (newType == null) {                    throw new ConfigurationException("Cannot clone traintype "                                                     + defaultType.getName());                }            } else {                newType = new TrainType(true);            }            lTrainTypes.add(newType);            newType.configureFromXML(typeTag);            mTrainTypes.put(newType.getName(), newType);        }        // Special train buying rules        Tag rulesTag = tag.getChild("TrainBuyingRules");        if (rulesTag != null) {            // A 1851 special            trainPriceAtFaceValueIfDifferentPresidents = rulesTag.getChild("FaceValueIfDifferentPresidents") != null;        }        // Finish initialisation of the train types        for (TrainTypeI type : lTrainTypes) {            if (type.getReleasedTrainTypeNames() != null) {                List<TrainTypeI> rtts = new ArrayList<TrainTypeI>(2);                for (String ttName : type.getReleasedTrainTypeNames().split(",")) {                    rtts.add (mTrainTypes.get(ttName));                }                type.setReleasedTrainTypes(rtts);                        }            if (type.getRustedTrainTypeName() != null) {                type.setRustedTrainType(mTrainTypes.get(type.getRustedTrainTypeName()));                mTrainTypes.get(type.getRustedTrainTypeName()).setPermanent(false);            }        }                // Are trains sold to foreigners?        Tag removeTrainTag = tag.getChild("RemoveTrainBeforeSR");        if (removeTrainTag != null) {            // Trains "bought by foreigners" (1844, 1824)            removeTrain = true; // completed in finishConfiguration()        }            }    public void finishConfiguration (GameManagerI gameManager)    throws ConfigurationException {        this.gameManager = gameManager;        bank = gameManager.getBank();        ipo = bank.getIpo();        unavailable = bank.getUnavailable();        for (TrainTypeI type : lTrainTypes) {            type.finishConfiguration(gameManager);        }        // By default, set the first train type to "available".        newTypeIndex.set(0);        lTrainTypes.get(newTypeIndex.intValue()).setAvailable(bank);        // Trains "bought by foreigners" (1844, 1824)        if (removeTrain) {            gameManager.setGameParameter(GameDef.Parm.REMOVE_TRAIN_BEFORE_SR, true);        }                // Train trading between different players at face value only (1851)        gameManager.setGameParameter(GameDef.Parm.FIXED_PRICE_TRAINS_BETWEEN_PRESIDENTS,                trainPriceAtFaceValueIfDifferentPresidents);}    public void addTrain (String uniqueID, TrainI train) {        trainMap.put(uniqueID, train);    }    public TrainI getTrainByUniqueId(String id) {        return trainMap.get(id);    }    /**     * This method handles any consequences of new train buying (from the IPO),     * such as rusting and phase changes. It must be called <b>after</b> the     * train has been transferred.     *     */    public void checkTrainAvailability(TrainI train, Portfolio from) {        trainsHaveRusted = false;        phaseHasChanged = false;        if (from != ipo) return;        TrainTypeI boughtType, nextType;        boughtType = train.getType();        if (boughtType == (lTrainTypes.get(newTypeIndex.intValue()))            && ipo.getTrainOfType(boughtType) == null) {            // Last train bought, make a new type available.            newTypeIndex.add(1);            if (newTypeIndex.intValue() < lTrainTypes.size()) {                nextType = (lTrainTypes.get(newTypeIndex.intValue()));                if (nextType != null) {                    if (!nextType.isAvailable()) nextType.setAvailable(bank);                    trainAvailabilityChanged = true;                    ReportBuffer.add("All " + boughtType.getName()                                     + "-trains are sold out, "                                     + nextType.getName() + "-trains now available");                }            }        }        if (boughtType.getNumberBoughtFromIPO() == 1) {            // First train of a new type bought            ReportBuffer.add(LocalText.getText("FirstTrainBought",                    boughtType.getName()));            String newPhase = boughtType.getStartedPhaseName();            if (newPhase != null) {                gameManager.getPhaseManager().setPhase(newPhase);                phaseHasChanged = true;            }            TrainTypeI rustedType = boughtType.getRustedTrainType();            if (rustedType != null && !rustedType.hasRusted()) {                rustedType.setRusted(train.getHolder()); // Or obsolete,                // where applicable                 if (rustedType.isObsoleting()) {                    ReportBuffer.add(LocalText.getText("TrainsObsolete",                            rustedType.getName()));                } else {                    ReportBuffer.add(LocalText.getText("TrainsRusted",                        rustedType.getName()));                }                trainsHaveRusted = true;                trainAvailabilityChanged = true;            }            List<TrainTypeI> releasedTypes = boughtType.getReleasedTrainTypes();            if (releasedTypes != null) {                for (TrainTypeI releasedType : releasedTypes) {                    if (!releasedType.isAvailable()) {                        releasedType.setAvailable(bank);                    ReportBuffer.add(LocalText.getText("TrainsAvailable",                        releasedType.getName()));                    }                }                trainAvailabilityChanged = true;            }        }    }    public List<TrainI> getAvailableNewTrains() {        List<TrainI> availableTrains = new ArrayList<TrainI>();        TrainI train;        for (TrainTypeI type : lTrainTypes) {            if (type.isAvailable()) {                train = ipo.getTrainOfType(type);                if (train != null) {                    availableTrains.add(train);                }            }        }        return availableTrains;    }    public String getTrainCostOverview() {        StringBuffer b = new StringBuffer();        for (TrainTypeI type : lTrainTypes) {            if (b.length() > 1) b.append(" ");            b.append(type.getName()).append(":").append(Bank.format(type.getCost()));            if (type.getExchangeCost() > 0) {                b.append("(").append(Bank.format(type.getExchangeCost())).append(")");            }        }        return b.toString();    }        public TrainTypeI getTypeByName(String name) {        return mTrainTypes.get(name);    }    public List<TrainTypeI> getTrainTypes() {        return lTrainTypes;    }    public boolean hasAvailabilityChanged() {        return trainAvailabilityChanged;    }    public void resetAvailabilityChanged() {        trainAvailabilityChanged = false;    }    public boolean hasPhaseChanged() {        return phaseHasChanged;    }    public boolean isAnyTrainBought () {        return anyTrainBought.booleanValue();    }        public void setAnyTrainBought (boolean newValue) {        if (isAnyTrainBought() != newValue) {            anyTrainBought.set(newValue);        }    }}